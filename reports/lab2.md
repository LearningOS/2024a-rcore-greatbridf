# 总结实现功能
向`MemorySet`中加入了一些函数，用于检查虚拟地址段是否全有效（或全无效）。加入了函数用于创建以及删除一段映射。

用上面写的函数实现了`sys_mmap`和`sys_munmap`这两个系统调用。

实现了一个函数，用于验证权限并向一段虚拟地址写入数据，如果这段空间当前有映射但是没有页在页表中，则将其填上。

用上面写的函数实现了`sys_get_time`和`sys_task_info`这两个系统调用，具体的逻辑和上一次lab相同，不再重复叙述。

# 简答1

`[53:28]`位是ppn的高位
`[27:19]`位是ppn的中间部分
`[18:10]`位是ppn的低位

第7位标记这个页是否被写入过
第6位标记这个页面是否被访问过
第5位标记这个页面是否全局可用（和x86的G位相似）
第4位标记这个页面是否在U态下可访问
第3位标记这个页面上的代码是否可执行
第2位标记这个页面是否可以写入
第1位标记这个页面是否可以读取
第0位标记这个页面是否有效（present）

标记位这几位如果是pte那对应的就是页面的属性，如果是第$n(n\gt 0)$级页表中的项，那则表示下级所有的属性。

# 简答2

## 哪些异常可能是缺页导致的

`Instruction page fault`、`Load page fault`和`Store/AMO page fault`。分别对应取址、`load`和`store`时发生的缺页异常。

## 相关寄存器的值

`scause`表示异常的类型，就是上面对应的那三个。

`stval`表示发生缺页的虚拟地址。

## 这么做的好处

这样程序加载比较快，只要把对应的映射加上就可以开始执行了。如果执行的时候需要哪页再加载。有一些冷代码不需要一开始就加载费时间费空间。

## 大致占用的内存

一个页是`4K`，`10G / 4K = 2.5M`需要这么多个页，也就需要这些pte，一个pte是8b，`2.5M * 8 = 20M`，同时还没算上这些pte所需要在的其他级页表的大小就已经很大了。

## Lazy 策略

一开始不需要分配页以及分配下级页表，把这些页都设成not present，然后在进程对应的memory_set中记录对应的map情况以及对应映射的属性。然后如果访问的时候发生了page fault就去memory_set中检查这个vaddr对应的map区域的属性，如果属性不满足，比如向只读的页面中写入，那就把进程杀掉或者类似的操作。如果满足的话，再把下级页表给填上，分配页给他。

## 页面失效

把对应的`V`位给设成0。

# 简答3

## 单页表换页表

在进行切换的时候，换上当前进程的页表。

## 控制用户态无法访问内核页面

内核空间的pte的U位设成0。

## 单页表的优势

实现比较简单，不需要做一些复杂的切换。

## 双页表更换页表

在从用户态回到内核态，以及从内核态进入用户态的时候。因为用户态的页表里没有一部分内核空间的内容。

## 单页表操作系统什么时候换页表

只在进行用户进程调度的时候才换。因为所有的内核空间的内存映射都是一样的，如果不回到不同的用户进程，那不需要换页表。

# 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。
